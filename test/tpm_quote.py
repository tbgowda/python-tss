#!/usr/bin/python

import cffi
import sys
import binascii
import uuid
from pytss import *
from pytss.tspi_exceptions import *
from pytss.tspi_defines import *
#import M2Crypto
from M2Crypto import m2
from M2Crypto import RSA
import struct
'''
5c2e9aca-978c-4c05-9348-c9a9a51ae1e5
'''

srk_uuid = uuid.UUID('{00000000-0000-0000-0000-000000000001}')
#signKey_uuid = uuid.UUID('{5c2e9aca-978c-4c05-9348-c9a9a51ae1e5}')
signKey_uuid = uuid.UUID('{c135cccf-9004-4727-bab6-0a8368d3a27b}')

if __name__ == "__main__":

    context = TspiContext()
    context.connect()

    tpm = context.get_tpm_object()

    try:
	srk = context.load_key_by_uuid(TSS_PS_TYPE_SYSTEM, srk_uuid)

	signKey = context.load_key_by_uuid(TSS_PS_TYPE_SYSTEM, signKey_uuid)
	pubKey = signKey.get_pubkey()

	# PCR values to quote
	pcrRead = [1]
	# Challenge to pose
	challenge = 'alice'

	# Get the actual PCR values
	pcrvalues = {}
	for pcrIndex in pcrRead:
	    pcrvalues[pcrIndex] = binascii.hexlify(tpm.get_pcr(pcrIndex))
	    print pcrvalues[pcrIndex]

	# Prep PCR composite object to be used in quote
	pcrs = context.create_pcrs(tss_lib.TSS_PCRS_STRUCT_INFO)
	pcrs.set_pcrs(pcrRead)

	# The quote from the TPM returns
	# 1. TPM_QUOTE_INFO - rgbData (data), it includes challenge as well (externalData in TPM_QUOTE_INFO)
	# 2. Signed hash of TPM_QUOTE_INFO - rgbValidationData (validation)
	#
	# For reference (from TrouSerS implementation) :
	# typedef struct tdTPM_QUOTE_INFO                             /* 1.1b */
   	# {
    	#     TPM_STRUCT_VER     version;
    	#     BYTE               fixed[4];
        #     TPM_COMPOSITE_HASH compositeHash; /* in 1.2 TPM spec, named digestValue */
        #     TPM_NONCE          externalData;
        # } TPM_QUOTE_INFO;
	#
	# TPM_COMPOSITE_HASH : is a hash of the TPM_PCR_COMPOSITE structure
	# typedef struct tdTPM_PCR_COMPOSITE                          /* 1.1b */
	# {
	#     TPM_PCR_SELECTION select;
	#     UINT32            valueSize;
	#     SIZEIS(valueSize)
	#         TPM_PCRVALUE *pcrValue;
	# } TPM_PCR_COMPOSITE;
	#
	# typedef struct tdTPM_PCR_SELECTION                          /* 1.1b */
        # {
        #     UINT16    sizeOfSelect;
        #     SIZEIS(sizeOfSelect)
        #     BYTE *pcrSelect;
        #  } TPM_PCR_SELECTION;
	#
	# SIZEIS is a no-op on Linux
	#
	# On the remote server, we need to validate three things:
	# 1. Signature of rgbValidationData
	# 2. Validity of TPM_QUOTE_INFO
	#	a. Validity of compositeHash(this is a hash value of TPM_PCR_COMPOSITE) - to make sure the PCR readings are valid
	#	b. Validity of externalData(this is a hash value of challenge) - to make sure the challenge is valid

        data, validation = tpm.get_quote(signKey, pcrs, challenge)

        # Verify that the validation blob was generated by a trusted TPM
        pubkey = signKey.get_pubkey() # TODO: This will be sent by TPM to NSM

        n = m2.bin_to_bn(pubkey)
        n = m2.bn_to_mpi(n)
        e = m2.hex_to_bn("010001")
        e = m2.bn_to_mpi(e)
        rsa = RSA.new_pub_key((e, n))

        m = hashlib.sha1()
        m.update(data)
        md = m.digest()

        try:
            ret = rsa.verify(md, str(validation), algo='sha1')
	    print 'Signature is valid'
        except RSA.RSAError:
            print 'Invalid signature'

	# Now, verify if the PCRs are valid
        select = 0
        maxpcr = 0

	# Remote server needs to independently Form the TPM_PCR_COMPOSITE structure
        values = bytearray()
        for pcr in sorted(pcrvalues): # TODO: pcrvalues will be sent by TPM to NSM
            values += binascii.unhexlify(pcrvalues[pcr])
            select |= (1 << pcr)
            maxpcr = pcr

        if maxpcr < 16:
            header = struct.pack('!H', 2)
            header += struct.pack('@H', select)
            header += struct.pack('!I', len(values))
        else:
            header = struct.pack('!H', 4)
            header += struct.pack('@I', select)
            header += struct.pack('!I', len(values))

	# This pcr_blob is the TPM_PCR_COMPOSITE structure
        pcr_blob = header + values

	# Generate a hash value for this structure
        m = hashlib.sha1()
        m.update(pcr_blob)
        pcr_hash = m.digest()

	print binascii.hexlify(pcr_hash)
	print binascii.hexlify(data[8:28])

	# Remember that data is of type TPM_QUOTE_INFO, which is 48 bytes long.
	# The PCR_COMPOSITE_HASH starts at byte 8
        if pcr_hash == data[8:28]:
	    print 'PCR composite is valid'
        else:
	    print 'PCR composite is incorrect'

	# Now, verify if the challenge is valid
        m = hashlib.sha1()
        m.update(challenge)
        challenge_hash = m.digest()

	print binascii.hexlify(challenge_hash)
	print binascii.hexlify(data[28:48])

	# The externalData starts at byte 28
        if challenge_hash == data[28:48]:
	    print 'Challenge is valid'
        else:
	    print 'Incorrect challenge value'

    except tspi_exceptions:
        print "Error encountered"

